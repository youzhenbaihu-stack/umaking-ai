<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <meta name="robots" content="noindex, nofollow" />
    <title>ğŸ UMAKING AI PREDICTOR</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@stlite/mountable@latest/build/stlite.css" />
  </head>
  <body>
    <div id="root"></div>
    <script src="https://cdn.jsdelivr.net/npm/@stlite/mountable@latest/build/stlite.js"></script>
    <script>
      stlite.mount(
        {
          requirements: ["pandas", "plotly"],
          entrypoint: "uma_app.py",
          files: {
            "uma_app.py": `
import streamlit as st
import pandas as pd
import plotly.express as px

# ==========================================
# â˜…è¨­å®šã‚¨ãƒªã‚¢â˜…
# ==========================================
APP_PASSWORD = "777" 
# â–¼â–¼â–¼ è¦‹ã¤ã‘ã¦ã„ãŸã ã„ãŸå®Œç’§ãªURLã‚’ã‚»ãƒƒãƒˆã—ã¾ã—ãŸï¼ â–¼â–¼â–¼
CSV_URL = "https://raw.githubusercontent.com/youzhenbaihu-stack/umaking-ai/refs/heads/main/JRA_MASTER_2020-2024.csv"

st.set_page_config(page_title="UMAKING AI PREDICTOR", page_icon="ğŸ", layout="wide")

# ==========================================
# ğŸ” ãƒ­ã‚°ã‚¤ãƒ³èªè¨¼ã‚·ã‚¹ãƒ†ãƒ 
# ==========================================
def check_password():
    if "password_correct" not in st.session_state:
        st.markdown("<h1 style='text-align: center; color: #FFD700;'>ğŸ”’ UMAKING PRO LOGIN</h1>", unsafe_allow_html=True)
        pwd = st.text_input("PASSWORD", type="password", key="password_input")
        if pwd == APP_PASSWORD:
            st.session_state["password_correct"] = True
            st.rerun()
        elif pwd:
            st.error("ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒé•ã„ã¾ã™")
            
        st.markdown("---")
        st.markdown("<div style='text-align: center; color: #aaa;'>â€»æœ¬ã‚¢ãƒ—ãƒªã®åˆ©ç”¨ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯noteã§é™å®šå…¬é–‹ã—ã¦ã„ã¾ã™</div>", unsafe_allow_html=True)
        return False
    return True

if not check_password():
    st.stop()

# ==========================================
# ãƒ¡ã‚¤ãƒ³ã‚¢ãƒ—ãƒªç”»é¢
# ==========================================
st.title("ğŸ ç«¶é¦¬å ´ç‰¹åŒ–å‹ AIåˆ†æãƒ„ãƒ¼ãƒ«")
st.markdown("éå»ã®ãƒ“ãƒƒã‚°ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ã€**ã€Œã‚³ãƒ¼ã‚¹ã®ã‚¯ã‚»ï¼ˆæ é †ï¼‰ã€**ã¨**ã€Œæœ€å¼·ã®é¨æ‰‹ã€**ã‚’å°ãå‡ºã—ã¾ã™ã€‚")

@st.cache_data
def load_data(url):
    try:
        # GitHubã‹ã‚‰ç›´æ¥ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚€
        df = pd.read_csv(url)
        place_map = {
            "01": "æœ­å¹Œ", "02": "å‡½é¤¨", "03": "ç¦å³¶", "04": "æ–°æ½Ÿ", "05": "æ±äº¬",
            "06": "ä¸­å±±", "07": "ä¸­äº¬", "08": "äº¬éƒ½", "09": "é˜ªç¥", "10": "å°å€‰"
        }
        df['å ´æ‰€ã‚³ãƒ¼ãƒ‰'] = df['ãƒ¬ãƒ¼ã‚¹ID'].astype(str).str[4:6]
        df['ç«¶é¦¬å ´å'] = df['å ´æ‰€ã‚³ãƒ¼ãƒ‰'].map(place_map)
        df['è·é›¢'] = pd.to_numeric(df['è·é›¢'], errors='coerce')
        return df
    except Exception as e:
        return None

with st.spinner('ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚’èª­ã¿è¾¼ã‚“ã§ã„ã¾ã™...ï¼ˆæ•°ç§’ã‹ã‹ã‚Šã¾ã™ï¼‰'):
    df = load_data(CSV_URL)

if df is None or len(df) == 0:
    st.error("âŒ ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚")
    st.stop()

st.sidebar.header("ğŸ” ãƒ¬ãƒ¼ã‚¹æ¡ä»¶ã‚’è¨­å®š")

place_list = df['ç«¶é¦¬å ´å'].dropna().unique().tolist()
selected_place = st.sidebar.selectbox("ç«¶é¦¬å ´", place_list)

surface_list = df[df['ç«¶é¦¬å ´å'] == selected_place]['é¦¬å ´'].dropna().unique().tolist()
selected_surface = st.sidebar.radio("é¦¬å ´", surface_list)

available_distances = sorted(df[(df['ç«¶é¦¬å ´å']==selected_place) & (df['é¦¬å ´']==selected_surface)]['è·é›¢'].unique())
if len(available_distances) > 0:
    selected_distance = st.sidebar.selectbox("è·é›¢ (m)", available_distances)
else:
    st.sidebar.warning("ã“ã®æ¡ä»¶ã®ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“")
    st.stop()

if st.sidebar.button("ğŸš€ AIåˆ†æã‚¹ã‚¿ãƒ¼ãƒˆ", type="primary"):
    subset = df[
        (df['ç«¶é¦¬å ´å'] == selected_place) & 
        (df['é¦¬å ´'] == selected_surface) & 
        (df['è·é›¢'] == selected_distance)
    ]
    
    st.markdown("---")
    st.markdown(f"## ğŸ¯ åˆ†æçµæœï¼š{selected_place} {selected_surface}{selected_distance}m")
    st.caption(f"åˆ†æã«ä½¿ç”¨ã—ãŸãƒ‡ãƒ¼ã‚¿æ•°: {len(subset)} ä»¶")
    
    if len(subset) == 0:
        st.warning("æ¡ä»¶ã«ä¸€è‡´ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚")
        st.stop()

    col1, col2 = st.columns(2)
    
    with col1:
        st.subheader("ğŸ“Š æ é †åˆ¥ å‹ç‡ï¼ˆæœ‰åˆ©ãƒ»ä¸åˆ©ï¼‰")
        waku_stats = subset.groupby('æ ç•ª')[['1ç€ãƒ•ãƒ©ã‚°', '3ç€å†…ãƒ•ãƒ©ã‚°']].mean() * 100
        waku_stats = waku_stats.reset_index()
        waku_stats.columns = ['æ ç•ª', 'å‹ç‡(%)', 'è¤‡å‹ç‡(%)']
        
        fig = px.bar(waku_stats, x='æ ç•ª', y='å‹ç‡(%)', 
                     color='å‹ç‡(%)', color_continuous_scale='Reds',
                     title="æ ã”ã¨ã®å‹ç‡ï¼ˆèµ¤ã„ã»ã©å„ªç§€ï¼‰", text_auto='.1f')
        st.plotly_chart(fig, use_container_width=True)
        
        best_waku = waku_stats.loc[waku_stats['å‹ç‡(%)'].idxmax()]
        worst_waku = waku_stats.loc[waku_stats['å‹ç‡(%)'].idxmin()]
        st.info(f"**ğŸ’¡ AIã®çµè«–:** ã“ã®ã‚³ãƒ¼ã‚¹ã¯ **{int(best_waku['æ ç•ª'])}æ ** ãŒå‹ç‡{best_waku['å‹ç‡(%)']:.1f}%ã§æœ€å¼·ã§ã™ï¼\\né€†ã« **{int(worst_waku['æ ç•ª'])}æ ** ã¯å‹ç‡{worst_waku['å‹ç‡(%)']:.1f}%ã—ã‹ãªãå±é™ºã§ã™ã€‚")

    with col2:
        st.subheader("ğŸ† å¾—æ„ãªé¨æ‰‹ãƒ©ãƒ³ã‚­ãƒ³ã‚°")
        jockey_stats = subset.groupby('é¨æ‰‹')[['1ç€ãƒ•ãƒ©ã‚°', '3ç€å†…ãƒ•ãƒ©ã‚°']].agg(['mean', 'count'])
        jockey_stats.columns = ['å‹ç‡', 'é¨ä¹—æ•°', 'è¤‡å‹ç‡', 'del']
        jockey_stats = jockey_stats[['å‹ç‡', 'è¤‡å‹ç‡', 'é¨ä¹—æ•°']]
        
        jockey_stats = jockey_stats[jockey_stats['é¨ä¹—æ•°'] >= 3]
        jockey_stats['å‹ç‡'] = (jockey_stats['å‹ç‡'] * 100).round(1)
        jockey_stats['è¤‡å‹ç‡'] = (jockey_stats['è¤‡å‹ç‡'] * 100).round(1)
        
        ranking = jockey_stats.sort_values('å‹ç‡', ascending=False).head(10)
        st.dataframe(ranking[['å‹ç‡', 'è¤‡å‹ç‡', 'é¨ä¹—æ•°']], use_container_width=True)
        
        if len(ranking) > 0:
            top_jockey = ranking.index[0]
            st.success(f"**ğŸ‘‘ ç‹æ§˜:** **{top_jockey}** é¨æ‰‹ãŒå‹ç‡ **{ranking.iloc[0]['å‹ç‡']}%** ã§ãƒˆãƒƒãƒ—ï¼")
else:
    st.info("ğŸ‘ˆ å·¦ã®ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã§æ¡ä»¶ã‚’é¸ã‚“ã§ã€åˆ†æã‚¹ã‚¿ãƒ¼ãƒˆã‚’æŠ¼ã—ã¦ãã ã•ã„ï¼")
`
          }
        },
        document.getElementById("root")
      );
    </script>
  </body>
</html>
